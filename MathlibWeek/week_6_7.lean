import Mathlib.Data.Set.Lattice
import Mathlib.Data.Nat.Prime
import Mathlib.Data.Nat.Parity
import Mathlib.Data.Set.Lattice
import Mathlib.Data.Nat.Factorization.Basic
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Data.Real.Basic
import Mathlib.Tactic
import Mathlib.Algebra.Category.GroupCat.Basic

#check ‚àÄ x : ‚Ñù, 0 ‚â§ x ‚Üí |x| = x

#check ‚àÄ x y Œµ : ‚Ñù, 0 < Œµ ‚Üí Œµ ‚â§ 1 ‚Üí |x| < Œµ ‚Üí |y| < Œµ ‚Üí |x*y| < Œµ

variable {a : Type*}
variable { s t u : Set Œ± }
open Set

example (h : s ‚äÜ t) : s ‚à© u ‚äÜ t ‚à© u := by
  rw [subset_def, inter_def, inter_def]
  rw [subset_def] at h
  simp only [mem_setOf]
  rintro x ‚ü®xs, xu‚ü©
  exact ‚ü®h x xs, xu‚ü©

example (h : s ‚äÜ t) : s ‚à© u ‚äÜ t ‚à© u := by
  intro x xsu
  exact ‚ü®h xsu.1, xsu.2‚ü©


example : (s \ t) \ u ‚äÜ s \ (t ‚à™ u) := by
  intro x xstu
  have xs : x ‚àà s := xstu.1.1
  have xnt : x ‚àâ t := xstu.1.2
  have xnu : x ‚àâ u := xstu.2
  constructor
  ¬∑ exact xs
  intro xtu
  -- x ‚àà t ‚à® x ‚àà u
  rcases xtu with xt | xu
  ¬∑ show False; exact xnt xt
  . show False; exact xnu xu


variable {Œ± I : Type*}
variable (A B : I ‚Üí Set Œ±)
variable (s : Set Œ±)


example : (s ‚à© ‚ãÉ i, A i) = ‚ãÉ i, A i ‚à© s := by
  ext x
  simp only [mem_inter_iff, mem_iUnion]
  constructor
  rintro ‚ü®xs, ‚ü®i, xAi‚ü©‚ü©
  exact ‚ü®i, xAi, xs‚ü©
  rintro ‚ü®i, xAi, xs‚ü©
  exact ‚ü®xs, ‚ü®i, xAi‚ü©‚ü©



example : (‚ãÇ i, A i ‚à© B i) = (‚ãÇ i, A i) ‚à© ‚ãÇ i, B i := by
  ext x
  simp only [mem_inter_iff, mem_iInter]
  constructor
  ¬∑ intro h
    constructor
    ¬∑ intro i
      exact (h i).1
    intro i
    exact (h i).2
  rintro ‚ü®h1, h2‚ü© i
  constructor
  ¬∑ exact h1 i
  exact h2 i


example : (s ‚à™ ‚ãÇ i, A i) = ‚ãÇ i, A i ‚à™ s := by
  ext x
  simp only [mem_iInter, mem_inter_iff]
  by_cases xs : x ‚àà s
  constructor
  ¬∑ intro h s
    simp [mem_inter_iff]
    simp [xs]
  ¬∑ intro h2
    constructor
    exact xs
  ¬∑ simp
    constructor
    ¬∑ intro xs2 I
      simp [xs] at xs2
      simp [xs]
      exact (xs2 I)
    ¬∑ intro xs2
      simp [xs] at xs2
      simp [xs2]

def primes : Set ‚Ñï :=
  {x | Nat.Prime x}

variable {Œ± Œ≤ : Type*}
variable (f : Œ± ‚Üí Œ≤)
variable (s t : Set Œ±)
variable (u v : Set Œ≤)

open Function


-- if f : Œ± ‚Üí Œ≤, the library function defines preimage f p as f‚Åª¬π' to be {x | f x ‚àà p}
-- The expression x ‚àà f‚Åª¬π' p reduces f x ‚àà p.

example : f‚Åª¬π' (u ‚à© v) = f‚Åª¬π' u ‚à© f‚Åª¬π' v := by
  ext
  rfl

-- If s is a set of ele of type Œ± the library defs.
-- image f s as f'' s, to be {y | ‚àÉ x, x ‚àà s ‚àß (f x = y)}
-- y ‚àà f''s can decompose to a triplet: ‚ü®x,xs,xeq‚ü©

example : f '' (s ‚à™ t) = f '' s ‚à™ f '' t := by
  ext y
  constructor
  ¬∑ rintro ‚ü®x, xs | xt, rfl‚ü©
    ¬∑ left
      use x, xs
    right
    use x, xt
  rintro (‚ü®x, xs, rfl‚ü© | ‚ü®x,xt,rfl‚ü©)
  ¬∑ use x, Or.inl xs
  use x, Or.inr xt

example : s ‚äÜ f‚Åª¬π' (f '' s) := by
  intro x xs
  show f x ‚àà f '' s
  use x, xs

-- easy exercise
example : f '' s ‚äÜ v ‚Üî s ‚äÜ f‚Åª¬π' v := by
  exact image_subset_iff

variable {I : Type*} (A : I ‚Üí Set Œ±) (B : I ‚Üí Set Œ≤)

-- images and preimages with index unions and intersections
-- Note, the i: I is needed to setup a non-empty set
example : (f '' ‚ãÉ i, A i) = ‚ãÉ i, f '' A i := by
  ext y; simp
  constructor
  ¬∑ rintro ‚ü®x, ‚ü®i, xAi‚ü©, fxeq‚ü©
    use i, x
  rintro ‚ü®i, x, xAi, fxeq‚ü©
  exact ‚ü®x, ‚ü®i, xAi‚ü©, fxeq‚ü©


example : (f '' ‚ãÇ i, A i) ‚äÜ ‚ãÇ i, f '' A i := by
  intro y; simp
  intro x h fxeq i
  use x
  exact ‚ü®h i, fxeq‚ü©

#print Nat.Coprime

-- To claim that the fraction a/b where a, b ‚àà ‚Ñ§ is in lowest terms means that a and
-- b do not have any common factos, meaning they are coprime. Mathlib defines
-- Nat.Coprime m n to be Nat.gcd m n = 1.
-- if s and t are exp of type Nat we can write s.Coprime t, same for Nat.gcd
-- norm_num tactic can calc values

example (m n : Nat) (h : m.Coprime n) : m.gcd n = 1 := by
  rw [Nat.Coprime] at h
  exact h

example : Nat.Coprime 12 7 := by norm_num

#check Nat.prime_def_lt

example (p : ‚Ñï) (prime_p : Nat.Prime p) : 2 ‚â§ p ‚àß ‚àÄ m : ‚Ñï, m < p ‚Üí m ‚à£ p ‚Üí m = 1 := by
  rw [Nat.prime_def_lt] at prime_p
  assumption

-- If the square of a number is even, then the number is even

theorem even_of_even_sqr {m : ‚Ñï} (h : 2 ‚à£ m^2) : 2 ‚à£ m := by
  rw [pow_two, Nat.prime_two.dvd_mul] at h
  cases h <;> assumption

-- the @[ext] annotation tells lean to auto-gen theorems that can be used to prove
-- the two instances of a structure are equal when comp. are equal aka extensionality
@[ext]
structure Point where
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù

#check Point.ext
example (a b : Point) (hx : a.x = b.x) (hy : a.y = b.y) (hz : a.z = b.z) : a = b := by
  ext
  repeat' assumption

-- instance of point structure
def myPoint1 : Point where
  x := 2
  y := -1
  z := 4

-- We use protected keyword so that the name of the theorem is Point.add_comm
namespace Point

def add (a b : Point) : Point :=
  ‚ü®a.x + b.x, a.y + b.y, a.z + b.z‚ü©

protected theorem add_comm (a b : Point) : add a b = add b a := by
  rw [add, add]
  ext <;> dsimp
  repeat' apply add_comm

example (a b : Point) : add a b = add b a := by simp [add, add_comm]

protected theorem add_assoc (a b c : Point) : (a.add b).add c = a.add (b.add c) := by
  simp [add, add_assoc]

def smul (r : ‚Ñù) (a : Point) : Point :=
  ‚ü®r * a.x, r * a.y, r * a.z‚ü©

theorem smul_distrib (r : ‚Ñù) (a b : Point) : (smul r a).add (smul r b) = smul r (a.add b) := by
  simp [add, smul]
  simp [mul_add]

end Point

theorem add_x (a b : Point) : (a.add b).x = a.x + b.x :=
  rfl

-- algebraic structures are akin to the structure Point, the structure cmd is designed spec. to
-- generate algebraic structures.

structure Group‚ÇÅ (Œ± : Type*) where
  mul : Œ± ‚Üí Œ± ‚Üí Œ±
  one : Œ±
  inv : Œ± ‚Üí Œ±
  mul_assoc : ‚àÄ x y z : Œ±, mul (mul x y) z = mul x (mul y z)
  mul_one : ‚àÄ x : Œ±, mul x one = x
  one_mul : ‚àÄ x : Œ±, mul one x = x
  mul_left_inv : ‚àÄ x : Œ±, mul (inv x) x = one

#check Group‚ÇÅ
#check Group --Mathlib defined group

-- Group concatenation ‚Üì
structure Group‚ÇÅCat where
  Œ± : Type*
  str : Group‚ÇÅ Œ±


section
variable (Œ± Œ≤ Œ≥ : Type*)
variable (f : Œ± ‚âÉ Œ≤) (g : Œ≤ ‚âÉ Œ≥)

-- f : Œ± ‚âÉ Œ≤ is a bijection between Œ± and Œ≤
#check Equiv Œ± Œ≤
#check (f.toFun : Œ± ‚Üí Œ≤)
#check (f.invFun : Œ≤ ‚Üí Œ±)
#check (f.right_inv : ‚àÄ x : Œ≤, f (f.invFun x) = x)
#check (f.left_inv : ‚àÄ x : Œ±, f.invFun (f x) = x)
#check (Equiv.refl Œ± : Œ± ‚âÉ Œ±)
#check (f.symm : Œ≤ ‚âÉ Œ±)
#check (f.trans g : Œ± ‚âÉ Œ≥)

example (x : Œ±) : (f.trans g).toFun x = g.toFun (f.toFun x) := by
  rfl


-- exercise
-- AddGroup data type built to spec
structure AddGroup‚ÇÅ (Œ± : Type*) where
  add : Œ± ‚Üí Œ± ‚Üí Œ±
  zero : Œ±
  neg : Œ± ‚Üí Œ±
  add_assoc : ‚àÄ x y z : Œ±, add (add x y) z = add x (add y z)
  add_zero : ‚àÄ x : Œ±, add x zero = x
  zero_add : ‚àÄ x : Œ±, add x zero = x
  add_left_neg : ‚àÄ x : Œ±, add (neg x) x = zero

@[ext]
structure Point2 where
  x : ‚Ñù
  y : ‚Ñù
  z : ‚Ñù


namespace Point2

def add (a b : Point2) : Point2 :=
  ‚ü®a.x + b.x, a.y + b.y, a.z + b.z‚ü©

def negate (a : Point2) : Point2 :=
  ‚ü®-a.x, -a.y, -a.z‚ü©

def zero : Point2 := ‚ü®0, 0, 0‚ü©

-- A point under the AddGroup scheme
def addGroupPoint : AddGroup‚ÇÅ Point2 where
  add := Point2.add
  zero := Point2.zero
  neg := Point2.negate
  add_assoc := by simp [Point2.add, add_assoc]
  add_zero := by simp [Point2.add, Point2.zero]
  zero_add := by simp [Point2.add, Point2.zero]
  add_left_neg := by simp [Point2.add, Point2.negate, Point2.zero]

end Point2

-- Mathlib is setup to use generic group notation, for Equiv.Perm Œ±
variable {Œ± : Type*} (f g : Equiv.Perm Œ±) (n : ‚Ñï)
#check f * g
#check f * g * g‚Åª¬π
#check g ^ n

example : f * g * g‚Åª¬π = f := by rw [mul_assoc, mul_right_inv, mul_one]


-- Building the Guassian Inteers


-- The gaussians are the set of complex numbers s.t. {a + bi | a, b ‚àà ‚Ñ§}
@[ext]
structure gaussInt where
  re : ‚Ñ§
  im : ‚Ñ§

instance : Zero gaussInt :=
  ‚ü®‚ü®0, 0‚ü©‚ü©

instance : One gaussInt :=
  ‚ü®‚ü®1, 0‚ü©‚ü©

instance : Add gaussInt :=
  ‚ü®fun x y ‚Ü¶ ‚ü®x.re + y.re, x.im + y.im‚ü©‚ü©

instance : Neg gaussInt :=
  ‚ü®fun x ‚Ü¶ ‚ü®-x.re, -x.im‚ü©‚ü©

instance : Mul gaussInt :=
  ‚ü®fun x y ‚Ü¶ ‚ü®x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re‚ü©‚ü©

-- The above we are defining particular instances of Guassian ints use the aptly named "instance" key-word
-- Additionally doing the above allows lean's default tactics to do their thing.
 theorem zero_def : (0 : gaussInt) = ‚ü®0, 0‚ü© :=
  rfl

theorem one_def : (1 : gaussInt) = ‚ü®1, 0‚ü© :=
  rfl

theorem add_def (x y : gaussInt) : x + y = ‚ü®x.re + y.re, x.im + y.im‚ü© :=
  rfl

theorem neg_def (x : gaussInt) : -x = ‚ü®-x.re, -x.im‚ü© :=
  rfl

theorem mul_def (x y : gaussInt) :
    x * y = ‚ü®x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re‚ü© :=
  rfl

@[simp]
theorem zero_re : (0 : gaussInt).re = 0 :=
  rfl


class One‚ÇÅ (Œ± : Type) where
  one : Œ±

#check One‚ÇÅ.one

@[class] structure One‚ÇÇ (Œ± : Type) where
  one : Œ±

#check One‚ÇÇ.one -- writing @[class] keeps the second arg explicit

-- We will assign notation to One‚ÇÅ.one
@[inherit_doc]
notation "ùüô" => One‚ÇÅ.one

-- Data carrying class
class Dia‚ÇÅ (Œ± : Type) where
  dia : Œ± ‚Üí Œ± ‚Üí Œ±

infixl:70 "‚óá" => Dia‚ÇÅ.dia

class Semigroup‚ÇÅ (Œ± : Type) where
  toDia‚ÇÅ : Dia‚ÇÅ Œ±
  dia_assoc : ‚àÄ a b c : Œ±, a ‚óá b ‚óá c = a ‚óá (b ‚óá c)

-- We additionally need to state toDia is in attribute of Semigroup‚ÇÅ as it is not in type class's
-- database
attribute [instance] Semigroup‚ÇÅ.toDia‚ÇÅ

-- without needing attribute
class Semigroup‚ÇÇ (Œ± : Type) extends Dia‚ÇÅ Œ± where
  dia_assoc : ‚àÄ a b c : Œ±, a ‚óá b ‚óá c = a ‚óá (b ‚óá c)

example {Œ± : Type} [Semigroup‚ÇÇ Œ±] (a b : Œ±) : Œ± := a ‚óá b

class DiaOneClass‚ÇÅ (Œ± : Type) extends One‚ÇÅ Œ±, Dia‚ÇÅ Œ± where
  one_dia : ‚àÄ a : Œ±, ùüô ‚óá a = a
  dia_one : ‚àÄ a : Œ± , a ‚óá ùüô = a
-- A monoid has an associativty operation and an identity operation
class Monoid‚ÇÅ (Œ± : Type) extends Semigroup‚ÇÅ Œ±, DiaOneClass‚ÇÅ Œ±
#check Monoid‚ÇÅ

class Inv‚ÇÅ (Œ± : Type) where
  inv : Œ± ‚Üí Œ±

@[inherit_doc]
postfix:max "‚Åª¬π" => Inv‚ÇÅ.inv

class Group‚ÇÉ (G : Type) extends Monoid‚ÇÅ G, Inv G where
  inv_dia : ‚àÄ a : G, a‚Åª¬π ‚óá a = ùüô

lemma left_inv_eq_right_inv‚ÇÉ {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚óá a = ùüô) (hac : a ‚óá c = ùüô) : b = c :=
  by rw [<- DiaOneClass‚ÇÅ.one_dia c, <- hba, Semigroup‚ÇÅ.dia_assoc, hac, DiaOneClass‚ÇÅ.dia_one b]

export DiaOneClass‚ÇÅ (one_dia dia_one)
export Semigroup‚ÇÅ (dia_assoc)
export Group‚ÇÉ (inv_dia)
-- copies the aboce lemmas into root name space

example {M : Type} [Monoid‚ÇÅ M] {a b c : M} (hba : b ‚óá a = ùüô) (hac : a ‚óá c = ùüô) : b = c :=
  by
  rw [<- one_dia c, <- hba, dia_assoc, hac, dia_one]

-- exercises :)

lemma inv_eq_of_dia [Group‚ÇÉ G] {a b : G} (h : a ‚óá b = ùüô) : a‚Åª¬π = b :=
  left_inv_eq_right_inv‚ÇÉ (inv_dia a) h

lemma dia_inv [Group‚ÇÉ G] (a : G) : a ‚óá a‚Åª¬π = ùüô := by
  rw [<- inv_dia a‚Åª¬π, inv_eq_of_dia (inv_dia a)]


-- Classes and Structures are defined in both additive and multiplicative notation
-- with an attr. to_additive
class AddSemigroup‚ÇÉ (Œ± : Type) extends Add Œ± where
  add_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a + b + c = a + (b + c)

@[to_additive AddSemigroup‚ÇÉ]
class Semigroup‚ÇÉ (Œ± : Type) extends Mul Œ± where
  mul_assoc‚ÇÉ : ‚àÄ a b c : Œ±, a * b * c = a * (b * c)

class AddMonoid‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ±, AddZeroClass Œ±

@[to_additive AddMonoid‚ÇÉ]
class Monoid‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ±, MulOneClass Œ±

attribute [to_additive existing] Monoid‚ÇÉ.toMulOneClass

export Semigroup‚ÇÉ (mul_assoc‚ÇÉ)
export AddSemigroup‚ÇÉ (add_assoc‚ÇÉ)

@[to_additive]
lemma left_inv_eq_right_inv' {M : Type} [Monoid‚ÇÉ M] {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c := by
  rw [‚Üê one_mul c, ‚Üê hba, mul_assoc‚ÇÉ, hac, mul_one b]

#check left_neg_eq_right_neg'


class AddCommSemigroup‚ÇÉ (Œ± : Type) extends AddSemigroup‚ÇÉ Œ± where
  add_comm : ‚àÄ a b : Œ±, a + b = b + a

@[to_additive AddCommSemigroup‚ÇÉ]
class CommSemigroup‚ÇÉ (Œ± : Type) extends Semigroup‚ÇÉ Œ± where
  mul_comm : ‚àÄ a b : Œ±, a * b = b * a

class AddCommMonoid‚ÇÉ (Œ± : Type) extends AddMonoid‚ÇÉ Œ±, AddCommSemigroup‚ÇÉ Œ±

@[to_additive AddCommMonoid‚ÇÉ]
class CommMonoid‚ÇÉ (Œ± : Type) extends Monoid‚ÇÉ Œ±, CommSemigroup‚ÇÉ Œ±

class AddGroup‚ÇÑ (G : Type) extends AddMonoid‚ÇÉ G, Neg G where
  neg_add : ‚àÄ a : G, -a + a = 0

@[to_additive AddGroup‚ÇÑ]
class Group‚ÇÑ (G : Type) extends Monoid‚ÇÉ G, Inv G where
  inv_mul : ‚àÄ a : G, a‚Åª¬π * a = 1

attribute [simp] Group‚ÇÑ.inv_mul AddGroup‚ÇÑ.neg_add

-- exercises
-- Note, Groups are Monoids with inverse elements
-- Semigroups are groups with associativity

@[to_additive]
lemma inv_eq_of_mul [Group‚ÇÑ G] {a b : G} (h : a * b = 1) : a‚Åª¬π = b :=
  left_inv_eq_right_inv' (Group‚ÇÑ.inv_mul a) h


@[to_additive (attr := simp)]
lemma Group‚ÇÑ.mul_inv {G : Type} [Group‚ÇÑ G] {a : G} : a * a‚Åª¬π = 1 := by
  rw [‚Üê inv_mul a‚Åª¬π, inv_eq_of_mul (inv_mul a)]

@[to_additive]
lemma mul_left_cancel‚ÇÉ {G : Type} [Group‚ÇÑ G] {a b c : G} (h : a * b = a * c) : b = c := by
  simpa [‚Üê mul_assoc‚ÇÉ] using congr_arg (a‚Åª¬π * ¬∑) h

-- apply associativity of our group then try to simplify after apply a congr_argument where
-- we substitute h in for ¬∑

@[to_additive]
lemma mul_right_cancel‚ÇÉ {G : Type} [Group‚ÇÑ G] {a b c : G} (h : b*a = c*a) : b = c := by
  simpa [mul_assoc‚ÇÉ] using congr_arg (¬∑ * a‚Åª¬π) h
